error.bufferblob.flush_icache_stub=Crash in BufferBlob::flush_icache_stub. Reference: https://access.redhat.com/solutions/5658041.
error.compiler.thread=JVM crash in CompilerThread. Reference: https://access.redhat.com/solutions/20195.
error.direct.byte.buffer.contention=It appears there is an application issue resulting in 2 threads attempting to modify a java.nio.ByteBuffer at the same time (e.g. one thread closing/cleaning it while another thread tries to write to it). ByteBuffer is not thread safe and must be accessed in a synchronized manner. Reference: https://access.redhat.com/solutions/5625311.
error.heap.plus.metaspace.gt.physical.memory=The memory reserved for the heap and metaspace is greater than the physical memory. This can lead to swapping (very bad for Java performance) or the process being terminated (oom killer). Either increase physical memory or decrease heap size to avoid swapping. The memory required by the JVM process is the sum of the following: (1) Heap. (2) Metaspace. (3) Thread Stack (thread stack size X number of threads). (4) JVM native memory. (5) A safety factor.
error.jdk8.rhel7.power8.rpm.on.power9=It appears that the power8 rpm from rhel-7-for-power-le-rpms repo is installed on a POWER9 cpu. This is not tested/supported.
error.jdk8.shenandoah.root.updater=ShenadoahRootUpdater bug fixed in OpenJDK8 u282. Reference: https://access.redhat.com/solutions/5581321.
error.jdk8.shenandoah.mark.loop.work=Java crash in GCTaskThread while Shenandoah collector concurrent marking. Reference: https://access.redhat.com/solutions/5581301.
error.jdk8.zipfile.contention=There is an application or ops invalid use case resulting in an attempt to modify a file while Java has it open. A workaround to avoid the crash is to disable memory mapping in ZipFile with -Dsun.zip.disableMemoryMapping=true (at the cost of some loss in performance), or upgrade to JDK 11. Backporting a fix to JDK8 would not address the root cause, and the OpenJDK developers have determined it is too risky. References: (1) https://access.redhat.com/solutions/65104. (2) https://bugs.openjdk.java.net/browse/JDK-8142508.
error.jna=The crash is happening in JNA code. JNA is not part of the Java JDK. The JNA library is distributed with the application and is therefore application code and not supported by the JDK vendor. Next steps for troubleshooting should be from the JNA vendor. The JDK vendor will provide support for the underlying JDK if the JNA vendor finds an issue with a valid/supported use case.
error.jna.rh=The crash is happening in JNA code. JNA is not part of the Java JDK. The JNA library is distributed with the application and is therefore application code and not supported by Red Hat. Next steps for troubleshooting should be from the JNA vendor. Red Hat will provide support for the underlying JDK if the JNA vendor finds an issue with a valid/supported use case.
error.jvm.dll=JVM crash inside jvm.dll. https://access.redhat.com/solutions/464203.
error.libaio.context.done=JVM crash in org.apache.activemq.artemis.nativo.jlibaio.LibaioContext.done() method. Reference: https://access.redhat.com/solutions/5080901.
error.libjvm.so=JVM crash inside libjvm.so. Reference: https://access.redhat.com/solutions/442903.
error.oome=Insufficient physical memory. Check if memory exhaustion is due solely to the JVM, or external processes are consuming significant amounts of memory.
error.oome.compressed.oops=The java heap is blocking the growth of the native heap due to CompressedOops enabled. Disable CompressedOops or set -XX:HeapBaseMinAddress=n higher. Reference: https://access.redhat.com/solutions/2697961.
error.oome.external=Insufficient physical memory when Java heap + metaspace <95% physical memory. Either increase physical memory or decrease the memory demands from external processes and/or the JVM process. The JVM process size can be decreased by decreasing one of following: (1) Heap. (2) Metaspace. (3) Thread Stack (thread stack size X number of threads). (4) JVM native memory.
error.oome.java.heap="OutOfMemoryError: Java heap space" detected. Either there is unintended object retention, or the heap is too small. If there are multiple OutOfMemoryErrors, check to see if they are being caught and preventing the JVM from exiting. OutOfMemoryError should not be caught, as it leaves the JVM in an undetermined state. Reference: https://access.redhat.com/solutions/37055.
error.oome.jvm=Insufficient physical memory when Java heap + metaspace >=95% physical memory. Either increase physical memory or decrease the JVM process size by decreasing one of following: (1) Heap. (2) Metaspace. (3) Thread Stack (thread stack size X number of threads). (4) JVM native memory.
error.oome.startup=There is not enough physical memory for the JVM to start. Either reduce the JVM memory needs (e.g. decrease the heap size), eliminate other processes outside the JVM competing for memory, and/or increase the available physical memory.
error.opt.remote.debugging.enabled=Remote debugging is enabled (e.g. -agentlib:jdwp=transport=dt_socket,address=8787,server=y,suspend=n). This is for debugging in lower environments and should not be enabled in production due to performance, security, and stability concerns.
error.pthread.getcpuclockid=Reference: https://access.redhat.com/solutions/5317181.
error.stack.freespace.gt.stack.size=The stack free space reported is larger than the expected stack size. Investigate if the crash happened due to StackOverflow and left the stack in an undetermined state. Reference: https://access.redhat.com/solutions/36593.
error.stackoverflow=StackOverflowError detected. Either there is unintended recursion, or the stack is too small. If there are multiple StackOverflowErrors, check to see if they are being caught and preventing the JVM from exiting. StackOverflowError should not be caught, as it leaves the JVM in an undetermined state. Reference: https://access.redhat.com/solutions/27221.
error.stubroutines=JVM crash in StubRoutines. Reference: https://access.redhat.com/solutions/4466551.
info.adoptopenjdk.possible=JDK appears to be an AdoptOpenJDK build of OpenJDK.
info.cgroup=The JVM is running in a cgroup environment.
info.cgroup.memory.limit=The memory available to the JVM is restricted by the container.
info.jdk.ancient=The JDK is very old. Has the application been running without issue in production for a long time? Has something changed recently (e.g. application upgrade, load, etc.) that might have triggered the issue?
info.jvm.startup.fails=The JVM fails to start.
info.memory.jvm.ne.system=The physical memory reported by the JVM does not match the system memory (e.g. meminfo MemTotal).
info.opt.comp.class.size.comp.oops.disabled=Compressed class pointers space size is not being used due to compressed object references being disabled (-XX:-UseCompressedOops).
info.opt.comp.class.size.comp.class.disabled=Compressed class pointers space size is not being used due to compressed class pointers being disabled (-XX:-UseCompressedClassPointers).  
info.opt.comp.class.size.not.set=When UseCompressedOops and UseCompressedClassesPointers (JDK 1.8 u40+) are enabled (default) the Metaspace reported in the GC logging is the sum of two native memory spaces: (1) class metadata. (2) compressed class pointers. It is recommended to explicitly set the compressed class pointers space. For example: -XX:CompressedClassSpaceSize=1G.
info.opt.heap.dump.on.oome.missing=Add -XX:+HeapDumpOnOutOfMemoryError. This option does not impact performance (until the heap is actually written out); it is simply a flag to indicate that a heap dump should be generated when the first thread throws OutOfMemoryError. Generally this JVM argument should always be used, as it provides critical information in case of a memory error.
info.opt.heap.dump.path.filename=It appears that a heap dump file name has been specified with the -XX:HeapDumpPath (e.g. -XX:HeapDumpPath=/mydir/heapdump.hprof). Generally you only want to specify a directory (e.g. -XX:HeapDumpPath=/mydir/) and let the JVM use the default file name, which includes the process id. If you specify a file name, heap dumps will overwrite each other. Unless disk space is a concern, you typically do not want to overwrite heap dumps and lose data. Reference: https://access.redhat.com/solutions/21109
info.opt.heap.dump.path.missing=Use the -XX:HeapDumpPath option to specify a directory where heap dumps are created (e.g. -XX:HeapDumpPath=/mypath/). If this option is not used, heap dumps will be created in the directory defined by the user.dir environment variable.
info.opt.max.perm.size=There is an attempt to set the maximum permanent generation size with -XX:MaxPermSize. The permanent generation space was replaced by the metaspace in JDK8. The option is being ignored and should be removed.
info.opt.metaspace=Initial and/or max metaspace size is being set. This is generally not recommended. Reference: https://access.redhat.com/solutions/1489263.
info.opt.undefined=Undefined JVM option(s):
info.opt.verbose.class=Class loading logging is enabled with -verbose:class. This is not a standard recommended logging option and is typically only enabled for special troubleshooting/analysis. If there is no reason to use it, remove it for less overhead.
info.rh.build.centos=Red Hat build of OpenJDK on CentOS.
info.rh.build.linux.zip=Red Hat build of OpenJDK Linux zip install.
info.rh.build.not=JDK does not appear to be a Red Hat build (e.g. Oracle, AdoptOpenJDK, Azul).
info.rh.build.possible=Red Hat build of OpenJDK possible, but not positively identified.
info.rh.build.rpm=Red Hat build of OpenJDK rpm install.
info.rh.build.windows.zip=Red Hat build of OpenJDK Windows zip install.
info.sigcode.bus.adraln=Signal code BUS_ADRALN: The memory address that has an invalid address alignment for the CPU.
info.sigcode.bus.adrerr=Signal code BUS_ADRERR: The memory address does not exist.
info.sigcode.bus.adrerr.linux=Signal code BUS_ADRERR: The memory address does not exist. This can happen on Linux when an mmap'ed file is truncated (e.g. a threading issue where 2 threads access a file at the same time).
info.sigcode.bus.objerr=Signal code BUS_OBJERR: Hardware issue.
info.sigcode.ill.illopn=Signal code ILL_ILLOPN: Illegal operand.
info.sigcode.segv.accerr=Signal code SEGV_ACCERR: The access is not allowed. For example: (1) Attempting to write to read-only memory. (2) Attempting to write to protected (OS) memory. (3) Attempting to access an array at an index greater than the array size (out of bounds).
info.sigcode.segv.maperr=Signal code SEGV_MAPERR: The memory address is not mapped to an object.
info.sigcode.si.kernel=Signal code SI_KERNEL: Sent by the kernel.
info.sigcode.si.user=Signal code SI_USER: Sent by kill.
info.signo.exception.access.violation=Signal code EXCEPTION_ACCESS_VIOLATION: Segmentation fault. Accessing valid memory in an invalid way.
info.signo.sigbus=Signal number SIGBUS: Invalid memory address.
info.signo.sigill=Signal number SIGILL: Illegal instruction at the processor.
info.signo.sigsegv=Signal number SIGSEGV: Segmentation fault. Accessing valid memory in an invalid way.
info.stack.no.vm.code=The stack trace does not contain VM code.
info.storage.aws=AWS block storage.
info.storage.unknown=Unknown storage.
info.swap.disabled=Swap has been disabled. This can be an indication the JVM is running in a container environment. Reference: https://access.redhat.com/solutions/3242331.
info.swapping=>5% swap space being used at the time of the crash. This is not necessarily bad. It is only a snapshot in time, and it doesn't necessarily mean the Java process is swapping. However, since swapping is very bad for Java performance, it should be verified that the Java process is indeed not swapping.
info.truncated=Truncated fatal error log.
warn.jdk.debug.symbols=Verify the JDK debug symbols are installed. Debug symbols can provide more detailed information in the fatal error log that is critical for analyzing issues in VM code. If they are not installed, reproduce the issue with the JDK debug symbols installed. Reference: https://access.redhat.com/solutions/5419761.
warn.jdk.not.latest=JDK is not the latest version. Latest version is 
warn.jdk.not.lts=JDK is not a Long Term Support (LTS) version.
warn.opt.adaptive.size.policy.disabled=Adaptive size policy is disabled (-XX:-UseAdaptiveSizePolicy), and minimum heap size (-Xms, -XX:InitialHeapSize) and maximum heap size (-Xmx, -XX:MaxHeapSize) are not equal. The JVM will not be able to increase the heap beyond the minimum heap size. Remove -XX:-UseAdaptiveSizePolicy. Reference: https://access.redhat.com/solutions/5565311.
warn.opt.cms.parallel.initial.mark.disabled=Multi-threaded CMS initial mark is disabled with -XX:-CMSParallelInitialMarkEnabled. Remove -XX:-CMSParallelInitialMarkEnabled and let the JVM determine the setting based on resources.
warn.opt.cms.parallel.remark.disabled=Multi-threaded CMS remark is disabled with -XX:-CMSParallelRemarkEnabled. Remove -XX:-CMSParallelRemarkEnabled and let the JVM determine the setting based on resources.
warn.opt.comp.class.disabled.heap.lt.32g=Compressed class pointers are disabled with -XX:-UseCompressedClassPointers, and heap < 32G. One disadvantage of 64-bit is increased heap size due to increased pointer size. Compressed class pointers can be used on heaps < 32G to compress references to 32 bits, allowing class pointer and heap sizes on the order of 32-bit. Remove -XX:-UseCompressedClassPointers and let the JVM determine the setting based on resources.
warn.opt.comp.class.disabled.heap.unk=Compressed class pointers are disabled with -XX:-UseCompressedClassPointers. One disadvantage of 64-bit is increased heap size due to increased pointer size. Compressed class pointers can be used on heaps < 32G to compress references to 32 bits, allowing class pointer and heap sizes on the order of 32-bit. Remove -XX:-UseCompressedClassPointers and let the JVM determine the setting based on resources.
warn.opt.comp.class.enabled.heap.gt.32g=Compressed class pointers are enabled with -XX:+UseCompressedClassPointers, and heap >= 32G. Compressed object references should not be used on heaps >= 32G. Remove -XX+-UseCompressedClassPointers and let the JVM determine the setting based on resources.
warn.opt.comp.class.size.heap.gt.32g=Compressed class pointers space size is set (-XX:CompressedClassSpaceSize), and heap >= 32G. Remove -XX:CompressedClassSpaceSize, as compressed object references should not be used on heaps >= 32G.
warn.opt.comp.oops.disabled.heap.lt.32g=Compressed object references are disabled with -XX:-UseCompressedOops, and heap < 32G. One disadvantage of 64-bit is increased heap size due to increased pointer size. Compressed class pointers can be used on heaps < 32G to compress references to 32 bits, allowing class pointer and heap sizes on the order of 32-bit. Remove -XX:-UseCompressedOops and let the JVM determine the setting based on resources.
warn.opt.comp.oops.disabled.heap.unk=Compressed object references are disabled with -XX:-UseCompressedOops. One disadvantage of 64-bit is increased heap size due to increased pointer size. Compressed class pointers can be used on heaps < 32G to compress references to 32 bits, allowing class pointer and heap sizes on the order of 32-bit. Remove -XX:-UseCompressedOops and let the JVM determine the setting based on resources.
warn.opt.comp.oops.enabled.heap.gt.32g=Compressed object references are enabled with -XX:+UseCompressedOops, and heap >= 32G. Compressed object references should not be used on heaps >= 32G. Remove -XX:+UseCompressedOops and let the JVM determine the setting based on resources.
warn.opt.heap.dump.on.oome.disabled=Remove -XX:-HeapDumpOnOutOfMemoryError and add -XX:+HeapDumpOnOutOfMemoryError instead (notice "+" vs. "-") for a heap dump to be generated when the first thread throws OutOfMemoryError. Generally this JVM argument should always be used, as it provides critical information in case of a memory error. 
warn.opt.metaspace.lt.comp.class=MaxMetaspaceSize is less than CompressedClassSpaceSize. MaxMetaspaceSize includes CompressedClassSpaceSize, so MaxMetaspaceSize should be larger than CompressedClassSpaceSize. If MaxMetaspaceSize is set smaller than CompressedClassSpaceSize, the JVM auto adjusts CompressedClassSpaceSize as follows: CompressedClassSpaceSize = MaxMetaspaceSize - (2 * InitialBootClassLoaderMetaspaceSize).
warn.rhel6=RHEL6 reached reached end of Maintenance Support II in November 2020. There will be no more RH builds of OpenJDK for RHEL6.
warn.swapping=Swap usage >= 20%. Memory usage should be monitored to determine if physical memory should be increased and/or memory demands decreased.
warn.thread.stack.size.small=Thread stack size is less than 128K.
warn.thread.stack.size.tiny=Thread stack size is less than 1K. Were units (e.g. 'K') left off by mistake?
warn.unidentified.log.line.report=Unidentified log line(s). Please submit an issue so we can investigate: https://github.com/mgm3746/errcat/issues.