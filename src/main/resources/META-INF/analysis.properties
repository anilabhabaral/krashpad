error.bufferblob.flush_icache_stub=Crash in BufferBlob::flush_icache_stub. Reference: https://access.redhat.com/solutions/5658041.
error.direct.byte.buffer.contention=It appears there is an application issue resulting in 2 threads attempting to modify a java.nio.ByteBuffer at the same time (e.g. one thread closing/cleaning it while another thread tries to write to it). ByteBuffer is not thread safe and must be accessed in a synchronized manner. Reference: https://access.redhat.com/solutions/5625311.
error.heap.plus.metaspace.gt.physical.memory=The memory reserved for the heap and metaspace is greater than the physical memory. This can lead to swapping (very bad for Java performance) or the process being terminated (oom killer). Either increase physical memory or decrease heap size to avoid swapping. The memory required by the JVM process is the sum of the following: (1) Heap. (2) Metaspace. (3) Thread Stack (thread stack size X number of threads). (4) JVM native memory. (5) A safety factor.
error.jdk8.rhel7.power8.rpm.on.power9=It appears that the power8 rpm from rhel-7-for-power-le-rpms repo is installed on a POWER9 cpu. This is not tested/supported.
error.jdk8.shenandoah.root.updater=ShenadoahRootUpdater bug fixed in OpenJDK8 u282. Reference: https://access.redhat.com/solutions/5581321.
error.jdk8.shenandoah.mark.loop.work=Java crash in GCTaskThread while Shenandoah collector concurrent marking. Reference: https://access.redhat.com/solutions/5581301.
error.jdk8.zipfile.contention=There is an application or ops invalid use case resulting in an attempt to modify a file while Java has it open. A workaround to avoid the crash is to disable memory mapping in ZipFile with -Dsun.zip.disableMemoryMapping=true (at the cost of some loss in performance), or upgrade to JDK 11. Backporting a fix to JDK8 would not address the root cause, and the OpenJDK developers have determined it is too risky. References: (1) https://access.redhat.com/solutions/65104. (2) https://bugs.openjdk.java.net/browse/JDK-8142508.
error.jna=The crash is happening in JNA code. JNA is not part of the Java JDK. The JNA library is distributed with the application and is therefore application code and not supported by the JDK vendor. Next steps for troubleshooting should be from the JNA vendor. The JDK vendor will provide support for the underlying JDK if the JNA vendor finds an issue with a valid/supported use case.
error.jna.rh=The crash is happening in JNA code. JNA is not part of the Java JDK. The JNA library is distributed with the application and is therefore application code and not supported by Red Hat. Next steps for troubleshooting should be from the JNA vendor. Red Hat will provide support for the underlying JDK if the JNA vendor finds an issue with a valid/supported use case.
error.jvm.dll=JVM crash inside jvm.dll. https://access.redhat.com/solutions/464203.
error.libaio.context.done=JVM crash in org.apache.activemq.artemis.nativo.jlibaio.LibaioContext.done() method. Reference: https://access.redhat.com/solutions/5080901.
error.libjvm.so=JVM crash inside libjvm.so. Reference: https://access.redhat.com/solutions/442903.
error.oome=Insufficient physical memory. Check if memory exhaustion is due solely to the JVM, or external processes are consuming significant amounts of memory.
error.oome.compressed.oops=The java heap is blocking the growth of the native heap due to CompressedOops enabled. Disable CompressedOops or set -XX:HeapBaseMinAddress=n higher. Reference: https://access.redhat.com/solutions/2697961.
error.oome.external=Insufficient physical memory when Java heap + metaspace <95% physical memory. Either increase physical memory or decrease the memory demands from external processes and/or the JVM process. The JVM process size can be decreased by decreasing one of following: (1) Heap. (2) Metaspace. (3) Thread Stack (thread stack size X number of threads). (4) JVM native memory.
error.oome.java.heap="OutOfMemoryError: Java heap space" detected. Either there is unintended object retention, or the heap is too small. If there are multiple OutOfMemoryErrors, check to see if they are being caught and preventing the JVM from exiting. OutOfMemoryError should not be caught, as it leaves the JVM in an undetermined state. Reference: https://access.redhat.com/solutions/37055.
error.oome.jvm=Insufficient physical memory when Java heap + metaspace >=95% physical memory. Either increase physical memory or decrease the JVM process size by decreasing one of following: (1) Heap. (2) Metaspace. (3) Thread Stack (thread stack size X number of threads). (4) JVM native memory.
error.oome.startup=There is not enough physical memory for the JVM to start. Either reduce the JVM memory needs (e.g. decrease the heap size), eliminate other processes outside the JVM competing for memory, and/or increaase the available physical memory.
error.pthread.getcpuclockid=Reference: https://access.redhat.com/solutions/5317181.
error.remote.debugging.enabled=Remote debugging is enabled (e.g. -agentlib:jdwp=transport=dt_socket,address=8787,server=y,suspend=n). This is for debugging in lower environments and should not be enabled in production due to performance, security, and stability concerns.
error.stack.freespace.gt.stack.size=The stack free space reported is larger than the expected stack size. Investigate if the crash happened due to StackOverflow and left the stack in an undetermined state. Reference: https://access.redhat.com/solutions/36593.
error.stackoverflow=StackOverflowError detected. Either there is unintended recursion, or the stack is too small. If there are multiple StackOverflowErrors, check to see if they are being caught and preventing the JVM from exiting. StackOverflowError should not be caught, as it leaves the JVM in an undetermined state. Reference: https://access.redhat.com/solutions/27221.
error.stubroutines=JVM crash in StubRoutines. Reference: https://access.redhat.com/solutions/4466551.
info.adoptopenjdk.possible=JDK appears to be an AdoptOpenJDK build of OpenJDK.
info.cgroup=The JVM is running in a cgroup environment.
info.cgroup.memory.limit=The memory available to the JVM is restricted by the container.
info.jdk.ancient=The JDK is very old. Has the application been running without issue in production for a long time? Has something changed recently (e.g. application upgrade, load, etc.) that might have triggered the issue?
info.jvm.startup.fails=The JVM fails to start.
info.memory.jvm.ne.system=The physical memory reported by the JVM does not match the system memory (e.g. meminfo MemTotal).
info.rh.build.centos=Red Hat build of OpenJDK on CentOS.
info.rh.build.linux.zip=Red Hat build of OpenJDK Linux zip install.
info.rh.build.not=JDK does not appear to be a Red Hat build (e.g. Oracle, AdoptOpenJDK, Azul).
info.rh.build.possible=Red Hat build of OpenJDK possible, but not positively identified.
info.rh.build.rpm=Red Hat build of OpenJDK rpm install.
info.rh.build.windows.zip=Red Hat build of OpenJDK Windows zip install.
info.sigcode.bus.adraln=Signal code BUS_ADRALN: The memory address that has an invalid address alignment for the CPU.
info.sigcode.bus.adrerr=Signal code BUS_ADRERR: The memory address does not exist.
info.sigcode.bus.adrerr.linux=Signal code BUS_ADRERR: The memory address does not exist. This can happen on Linux when an mmap'ed file is truncated (e.g. a threading issue where 2 threads access a file at the same time).
info.sigcode.bus.objerr=Signal code BUS_OBJERR: Hardware issue.
info.sigcode.ill.illopn=Signal code ILL_ILLOPN: Illegal operand.
info.sigcode.segv.accerr=Signal code SEGV_ACCERR: The access is not allowed. For example: (1) Attempting to write to read-only memory. (2) Attempting to write to protected (OS) memory. (3) Attempting to access an array at an index greater than the array size (out of bounds).
info.sigcode.segv.maperr=Signal code SEGV_MAPERR: The memory address is not mapped to an object.
info.sigcode.si.kernel=Signal code SI_KERNEL: Sent by the kernel.
info.sigcode.si.user=Signal code SI_USER: Sent by kill.
info.signo.exception.access.violation=Signal code EXCEPTION_ACCESS_VIOLATION: Segmentation fault. Accessing valid memory in an invalid way.
info.signo.sigbus=Signal number SIGBUS: Invalid memory address.
info.signo.sigill=Signal number SIGILL: Illegal instruction at the processor.
info.signo.sigsegv=Signal number SIGSEGV: Segmentation fault. Accessing valid memory in an invalid way.
info.stack.no.vm.code=The stack trace does not contain VM code.
info.storage.aws=AWS block storage.
info.storage.unknown=Unknown storage.
info.swap.disabled=Swap has been disabled. This can be an indication the JVM is running in a container environment. Reference: https://access.redhat.com/solutions/3242331.
info.swapping=>5% swap space being used at the time of the crash. This is not necessarily bad. It is only a snapshot in time, and it doesn't necessarily mean the Java process is swapping. However, since swapping is very bad for Java performance, it should be verified that the Java process is indeed not swapping.
info.truncated=Truncated fatal error log.
warn.jdk.debug.symbols=Verify the JDK debug symbols are installed. Debug symbols can provide more detailed information in the fatal error log that is critical for analyzing issues in VM code. If they are not installed, reproduce the issue with the JDK debug symbols installed. Reference: https://access.redhat.com/solutions/5419761.
warn.jdk.not.latest=JDK is not the latest version. Latest version is 
warn.jdk.not.lts=JDK is not a Long Term Support (LTS) version.
warn.rhel6=RHEL6 reached reached end of Maintenance Support II in November 2020. There will be no more RH builds of OpenJDK for RHEL6.
warn.swapping=Swap usage >= 20%. Memory usage should be monitored to determine if physical memory should be increased and/or memory demands decreased.
warn.thread.stack.size.small=Thread stack size is less than 128K.
warn.thread.stack.size.tiny=Thread stack size is less than 1K. Were units (e.g. 'K') left off by mistake?
warn.unidentified.log.line.report=Unidentified log line(s). Please submit an issue so we can investigate: https://github.com/mgm3746/errcat/issues.