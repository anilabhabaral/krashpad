error.bufferblob.flush_icache_stub=Crash in BufferBlob::flush_icache_stub. Reference: https://access.redhat.com/solutions/5658041.
error.direct.byte.buffer.contention=It appears there is an application issue resulting in 2 threads attempting to modify a java.nio.ByteBuffer at the same time (e.g. one thread closing/cleaning it while another thread tries to write to it). ByteBuffer is not thread safe and must be accessed in a synchronized manner. Reference: https://access.redhat.com/solutions/5625311.
error.heap.plus.metaspace.gt.physical.memory=The memory reserved for the heap and metaspace is greater than the physical memory. This can lead to swapping (very bad for Java performance) or the process being terminated (oom killer). Either increase physical memory or decrease heap size to avoid swapping. The memory required by the JVM process is the sum of the following: (1) Heap. (2) Metaspace. (3) Thread Stack (thread stack size X number of threads). (4) JVM native memory. (5) A safety factor.
error.jdk8.rhel7.power8.rpm.on.power9=It appears that the power8 rpm from rhel-7-for-power-le-rpms repo is installed on a POWER9 cpu. This is not tested/supported.
error.jdk8.shenandoah.root.updater=ShenadoahRootUpdater bug fixed in OpenJDK8 u282. Reference: https://access.redhat.com/solutions/5581321.
error.jdk8.zipfile.contention=There is an application or ops invalid use case resulting in an attempt to modify a file while Java has it open. A workaround to avoid the crash is to disable memory mapping in ZipFile with -Dsun.zip.disableMemoryMapping=true (at the cost of some loss in performance), or upgrade to JDK 11. Backporting a fix to JDK8 would not address the root cause, and the OpenJDK developers have determined it is too risky. References: (1) https://access.redhat.com/solutions/65104. (2) https://bugs.openjdk.java.net/browse/JDK-8142508.
error.jna=The crash is happening in JNA code. JNA is not part of the Java JDK. The JNA library is distributed with the application and is therefore application code and not supported by the JDK vendor. Next steps for troubleshooting should be from the JNA vendor. The JDK vendor will provide support for the underlying JDK if the JNA vendor finds an issue with a valid/supported use case.
error.jna.rh=The crash is happening in JNA code. JNA is not part of the Java JDK. The JNA library is distributed with the application and is therefore application code and not supported by Red Hat. Next steps for troubleshooting should be from the JNA vendor. Red Hat will provide support for the underlying JDK if the JNA vendor finds an issue with a valid/supported use case.
error.oome.java.heap=OutOfMemoryError: Java heap space detected. Either there is unintended object retention, or the heap is too small. If there are multiple OutOfMemoryErrors, check to see if they are being caught and preventing the JVM from exiting. OutOfMemoryError should not be caught, as it leaves the JVM in an undetermined state. Reference: https://access.redhat.com/solutions/37055.
error.oome.jvm.lt.physical.memory=The JVM crashed trying to allocate memory at a time when the sum of the Java heap + metaspace allocations was much less than the physical memory. Investigate if the unaccounted memory consumption is inside the JVM (native memory) or outside (other processes). Reference: https://access.redhat.com/solutions/19816.
error.oome.startup=There is not enough physical memory for the JVM to start. Either reduce the JVM memory needs (e.g. decrease the heap size), eliminate other processes outside the JVM competing for memory, and/or increaase the available physical memory.
error.pthread.getcpuclockid=Reference: https://access.redhat.com/solutions/5317181.
error.stack.freespace.gt.stack.size=The stack free space reported is larger than the expected stack size. Investigate if the crash happened due to StackOverflow and left the stack in an undetermined state. Reference: https://access.redhat.com/solutions/36593.
error.stackoverflow=StackOverflowError detected. Either there is unintended recursion, or the stack is too small. If there are multiple StackOverflowErrors, check to see if they are being caught and preventing the JVM from exiting. StackOverflowError should not be caught, as it leaves the JVM in an undetermined state. Reference: https://access.redhat.com/solutions/27221.
info.adoptopenjdk.possible=JDK appears to be an AdoptOpenJDK build of OpenJDK.
info.jdk.ancient=The JDK is very old. Has the application been running without issue in production for a long time? Has something changed recently (e.g. application upgrade, load, etc.) that might have triggered the issue?
info.jvm.startup.fails=The JVM fails to start.
info.rh.build.centos=Red Hat build of OpenJDK on CentOS.
info.rh.build.linux.zip=Red Hat build of OpenJDK Linux zip install.
info.rh.build.not=JDK does not appear to be a Red Hat build (e.g. Oracle, AdoptOpenJDK, Azul).
info.rh.build.possible=Red Hat build of OpenJDK possible, but not positively identified.
info.rh.build.rpm=Red Hat build of OpenJDK rpm install.
info.rh.build.windows.zip=Red Hat build of OpenJDK Windows zip install.
info.sigcode.bus.adraln=BUS_ADRALN: The memory address that has an invalid address alignment for the CPU.
info.sigcode.bus.adrerr=BUS_ADRERR: The memory address does not exist.
info.sigcode.bus.adrerr.linux=BUS_ADRERR: The memory address does not exist. This can happen on Linux when an mmap'ed file is truncated (e.g. a threading issue where 2 threads access a file at the same time).
info.sigcode.bus.objerr=BUS_OBJERR: Hardware issue.
info.sigcode.segv.accerr=SEGV_ACCERR: The access is not allowed. For example: (1) Attempting to write to read-only memory. (2) Attempting to write to protected (OS) memory. (3) Attempting to access an array at an index greater than the array size (out of bounds).
info.sigcode.segv.maperr=SEGV_MAPERR: The memory address is not mapped to an object.
info.signo.sigbus=SIGBUS: Invalid memory address.
info.signo.sigill= SIGILL: Illegal instruction at the processor.
info.signo.sigsegv=SIGSEGV: Segmentation fault. Accessing valid memory in an invalid way.
info.stack.no.vm.code=The stack trace does not contain VM code.
info.swapping=>5% swap space being used at the time of the crash. This is not necessarily bad. It is only a snapshot in time, and it doesn't necessarily mean the Java process is swapping. However, since swapping is very bad for Java performance, it should be verified that the Java process is indeed not swapping.
info.swap.disabled=Swap has been disabled. This can be an indication the JVM is running in a container environment. Reference: https://access.redhat.com/solutions/3242331.
warn.jdk.debug.symbols=Verify the JDK debug symbols are installed. Debug symbols can provide more detailed information in the fatal error log that is critical for analyzing issues in VM code. If they are not installed, reproduce the issue with the JDK debug symbols installed. Reference: https://access.redhat.com/solutions/5419761.
warn.jdk.not.latest=JDK not the latest version. Latest version is  
warn.jdk.not.lts=JDK is not a Long Term Support (LTS) version.
warn.rhel6=RHEL6 reached reached end of Maintenance Support II in November 2020. There will be no more RH builds of OpenJDK for RHEL6.
warn.unidentified.log.line.report=Unidentified log line(s). Please submit an issue so we can investigate: https://github.com/mgm3746/errcat/issues.