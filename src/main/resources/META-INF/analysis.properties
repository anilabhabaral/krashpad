error.bufferblob.flush_icache_stub=Crash in BufferBlob::flush_icache_stub. Reference: https://access.redhat.com/solutions/5658041.
error.cannot.get.library.information=Cannot get library information.
error.compiled.java.code=JVM crash when executing compiled java code. Reference: https://access.redhat.com/solutions/455823.
error.compiler.thread=JVM crash in CompilerThread. Reference: https://access.redhat.com/solutions/20195.
error.direct.byte.buffer.contention=It appears there is an application issue resulting in 2 threads attempting to modify a java.nio.ByteBuffer at the same time (e.g. one thread closing/cleaning it while another thread tries to write to it). ByteBuffer is not thread safe and must be accessed in a synchronized manner. Reference: https://access.redhat.com/solutions/5625311.
error.explicit.gc.disabled.eap7=Explicit garbage collection cannot be disabled on JBoss EAP7 because the IO subsystem uses direct memory (java.nio.DirectByteBuffer). The JVM uses explicit garbage collection to manage direct memory (to free space when MaxDirectMemorySize is reached), so disabling it can cause a memory leak. Remove -XX:+DisableExplicitGC, and if using the CMS or G1 collector, add -XX:+ExplicitGCInvokesConcurrent so explicit garbage collection is handled concurrently.
error.freetype.font.scaler.get.glyph.image.native=JVM crash due to a temporary font file being removed from java.io.tmpdir. Reference: https://access.redhat.com/solutions/4045621.
error.g1_par_scan_thread_state.copy_to_survivor_space=Crash in G1ParScanThreadState::copy_to_survivor_space. Reference: https://access.redhat.com/solutions/2075963.
error.heap.plus.metaspace.gt.physical.memory=The memory reserved for the heap and metaspace is greater than the physical memory. This can lead to swapping (very bad for Java performance) or the process being terminated (oom killer). Either increase physical memory or decrease heap size to avoid swapping. The memory required by the JVM process is the sum of the following: (1) Heap. (2) Metaspace. (3) Thread Stack (thread stack size X number of threads). (4) JVM native memory. (5) A safety factor.
error.jdk8.deflater.contention=There is an application or operations invalid use case resulting in an attempt to modify a file while Java has it open. A workaround to avoid the crash is to disable memory mapping in ZipFile with -Dsun.zip.disableMemoryMapping=true (at the cost of some loss in performance), or upgrade to JDK 11. Reference: https://access.redhat.com/solutions/2620091.
error.jdk8.rhel7.power8.rpm.on.power9=It appears that the power8 rpm from rhel-7-for-power-le-rpms repo is installed on a POWER9 cpu. This is not tested/supported.
error.jdk8.shenandoah.root.updater=ShenadoahRootUpdater bug fixed in OpenJDK8 u282. Reference: https://access.redhat.com/solutions/5581321.
error.jdk8.shenandoah.mark.loop.work=Java crash in GCTaskThread while Shenandoah collector concurrent marking. Reference: https://access.redhat.com/solutions/5581301.
error.jdk8.zipfile.contention=There is an application or operations invalid use case resulting in an attempt to modify a file while Java has it open. A workaround to avoid the crash is to disable memory mapping in ZipFile with -Dsun.zip.disableMemoryMapping=true (at the cost of some loss in performance), or upgrade to JDK 11. Backporting a fix to JDK8 would not address the root cause, and the OpenJDK developers have determined it is too risky. References: (1) https://access.redhat.com/solutions/65104. (2) https://bugs.openjdk.java.net/browse/JDK-8142508.
error.jfr.pd.get.top.frame=Java crash in JFR pd_get_top_frame_for_profiling. Reference: https://access.redhat.com/solutions/5964251.
error.jna=The crash involves JNA code. JNA is not part of the Java JDK. The JNA library is distributed with the application and is therefore application code and not supported by the JDK vendor. Next steps for troubleshooting should be from the JNA vendor. The JDK vendor will provide support for the underlying JDK if the JNA vendor finds an issue with a valid/supported use case.
error.jna.rh=The crash involves JNA code. JNA is not part of the Java JDK. The JNA library is distributed with the application and is therefore application code and not supported by Red Hat. Next steps for troubleshooting should be from the JNA vendor. Red Hat will provide support for the underlying JDK if the JNA vendor finds an issue with a valid/supported use case.
error.jvm.dll=JVM crash inside jvm.dll. https://access.redhat.com/solutions/464203.
error.libaio.context.done=JVM crash in org.apache.activemq.artemis.nativo.jlibaio.LibaioContext.done() method. Reference: https://access.redhat.com/solutions/5080901.
error.libjvm.so=JVM crash inside libjvm.so. Reference: https://access.redhat.com/solutions/442903.
error.null.pointer=The crash occurred dereferencing a null pointer (si_addr: 0x0000000000000000).
error.oome=Insufficient physical memory. Check if memory exhaustion is due solely to the JVM, or external processes are consuming significant amounts of memory.
error.oome.external=Insufficient physical memory when JVM heap + metaspace + class pointers + thread stack is <95% physical memory. Determine which of the following is consuming the unaccounted memory: (1) External process(es). (2) JVM native memory, (3) Hypervisor memory ballooning. Possible resolutions: (1) Increase physical memory. (2) Do hypervisor tuning to ensure memory swapping does not happen (e.g. reserve virtual machine memory). (3) Slim external processes. (4) Slim JVM (heap, metaspace, native memory, thread stack size, number of threads, etc.). 
error.oome.java.heap="OutOfMemoryError: Java heap space" detected. Either there is unintended object retention, or the heap is too small. If there are multiple OutOfMemoryErrors, check to see if they are being caught and preventing the JVM from exiting. OutOfMemoryError should not be caught, as it leaves the JVM in an undetermined state. Reference: https://access.redhat.com/solutions/37055.
error.oome.jvm=JVM heap + metaspace + class pointers + thread stack is >=95% physical memory. Either increase physical memory or slim the JVM process (heap, metaspace, native memory, thread stack size, number of threads, etc.).
error.oome.limit=The Out of Memory Error appears to be caused by a resource limit (rlimit) being reached. Check if the max user processes (nproc), kernel max number of threads (kernel.pid_max), open file limit (nofile), etc. is being reached. Reference: https://access.redhat.com/solutions/46410.
error.oome.limit.oops=The Out of Memory Error appears to be caused by one of the following limits being reached: (1) The native heap reached the java heap base address. Set -XX:HeapBaseMinAddress=n higher or disable CompressedOops with -XX:-UseCompressedOops. Reference: https://access.redhat.com/solutions/2697961. (2) A resource limit (rlimit) is reached. Check if the max user processes (nproc), kernel max number of threads (kernel.pid_max), open file limit (nofile), etc. is being reached. Reference: https://access.redhat.com/solutions/46410.
error.oome.oops=The Out of Memory Error appears to be caused by one of the following reasons: (1) Insufficient physical memory. Check if memory exhaustion is due solely to the JVM, or external processes are consuming significant amounts of memory. (2) The native heap reached the java heap base address. Set -XX:HeapBaseMinAddress=n higher or disable CompressedOops with -XX:-UseCompressedOops. Reference: https://access.redhat.com/solutions/2697961. 
error.oome.startup=It appears there is not enough physical memory for the JVM to start. Either reduce the JVM memory needs (e.g. decrease the heap size), eliminate other processes outside the JVM competing for memory, and/or increase the available physical memory.
error.oome.startup.external=It appears there is not enough physical memory for the JVM to start. Decrease memory demands on the box and/or increase the available physical memory. The JVM process size is < 50% of available memory so the likely candidates for memory slimming are processes outside the JVM. If collocating multiple JVM instances, reduce JVM memory needs (e.g. decrease heap size) and/or decrease the number of instances. If a VM environment, check if memory ballooning has consumed memory on the VM.
error.oome.startup.limit=The Out of Memory Error preventing the JVM from starting appears to be caused by a resource limit (rlimit) being reached. Check if the max user processes (nproc), kernel max number of threads (kernel.pid_max), open file limit (nofile), etc. is being reached. Reference: https://access.redhat.com/solutions/46410.
error.oome.startup.limit.oops=The Out of Memory Error preventing the JVM from starting appears to be caused by one of the following limits being reached: (1) The native heap reached the java heap base address. Set -XX:HeapBaseMinAddress=n higher or disable CompressedOops with -XX:-UseCompressedOops. Reference: https://access.redhat.com/solutions/2697961. (2) A resource limit (rlimit) is reached. Check if the max user processes (nproc), kernel max number of threads (kernel.pid_max), open file limit (nofile), etc. is being reached. Reference: https://access.redhat.com/solutions/46410.
error.opt.remote.debugging.enabled=Remote debugging is enabled (e.g. -agentlib:jdwp=transport=dt_socket,address=8787,server=y,suspend=n). This is for debugging in lower environments and should not be enabled in production due to performance, security, and stability concerns.
error.pthread.getcpuclockid=Reference: https://access.redhat.com/solutions/5317181.
error.stack.freespace.gt.stack.size=The stack free space reported is larger than the expected stack size. Investigate if the crash happened due to StackOverflow and left the stack in an undetermined state. Reference: https://access.redhat.com/solutions/36593.
error.stackoverflow=StackOverflowError detected. Either there is unintended recursion, or the stack is too small. If there are multiple StackOverflowErrors, check to see if they are being caught and preventing the JVM from exiting. StackOverflowError should not be caught, as it leaves the JVM in an undetermined state. Reference: https://access.redhat.com/solutions/27221.
error.stubroutines=JVM crash in StubRoutines. Reference: https://access.redhat.com/solutions/4466551.
info.adoptopenjdk.possible=JDK appears to be an AdoptOpenJDK build of OpenJDK.
info.cgroup=The JVM is running in a cgroup environment. This can be an indication the JVM is running in a container environment.
info.cgroup.memory.limit=The memory available to the JVM is restricted by cgroups memory_limit_in_bytes.
info.opt.heap.min.not.equal.max=For non-container production environments, it is recommended to set the initial heap size (-Xms, -XX:InitialHeapSize) and the maximum heap size (-Xmx, -XX:MaxHeapSize) to equal values for the following reasons: (1) It avoids the major (full) garbage collection the JVM has to do to resize the heap space. (2) If using large pages, memory is reserved for the JVM based on the maximum heap size, and there is no expectation that the memory will be used by any other process. (3) If using large pages, it avoids the case when other processes using large pages exhaust the large page memory and the OS reverts to using regular pages when the JVM asks to allocate more memory. For example: -Xms4096M -Xmx4096M.
info.jdk.ancient=The JDK is very old. Has the application been running without issue in production for a long time? Has something changed recently (e.g. application upgrade, load, etc.) that might have triggered the issue?
info.jffi=Check Java Foreign Function Interface (JFFI) usage. Reference: https://github.com/jnr/jffi.
info.jna=Check Java Native Access (JNA) usage. Reference: https://github.com/java-native-access.
info.jvm.startup.fails=The JVM fails to start.
info.jvm.user.ne.username=The USERNAME environment variable is different than the user the JVM process is running under.
info.memory.jvm.ne.system=The physical memory reported by the JVM does not match the system memory (e.g. meminfo MemTotal).
info.opt.cms.init.occupancy.only.missing=The CMS occupancy fraction, -XX:CMSInitiatingOccupancyFraction=N (default 92), is set without -XX:+UseCMSInitiatingOccupancyOnly enabled. Typically these options are used in combination with applications with large variances in object allocation and young generation promotion rates that prevent the CMS collector from accurately predicting when to start the CMS cycle. Consider adding/enabling -XX:+UseCMSInitiatingOccupancyOnly to disable heuristics (calculating anticipated promotions) and use only the occupancy fraction to determine when to trigger a CMS cycle.
info.opt.comp.class.size.comp.oops.disabled=Compressed class pointers space size is not being used due to compressed object references being disabled (-XX:-UseCompressedOops).
info.opt.comp.class.size.comp.class.disabled=Compressed class pointers space size is not being used due to compressed class pointers being disabled (-XX:-UseCompressedClassPointers).  
info.opt.comp.class.size.not.set=When UseCompressedOops and UseCompressedClassesPointers (JDK 1.8 u40+) are enabled (default) the Metaspace reported in the GC logging is the sum of two native memory spaces: (1) class metadata. (2) compressed class pointers. It is recommended to explicitly set the compressed class pointers space. For example: -XX:CompressedClassSpaceSize=1G.
info.opt.cruft.exp.gc.inv.con.and.unl.cla=The option -XX:-ExplicitGCInvokesConcurrentAndUnloadsClasses is unnecessary and can be removed because explicit garbage collection is disabled with -XX:+DisableExplicitGC.
info.opt.diagnostic.vm.options.enabled=Diagnostic JVM options are enabled with -XX:+UnlockDiagnosticVMOptions. Diagnostic options add additional overhead and are intended for troubleshooting issues, not general production use. Remove diagnostic options after completing troubleshooting: (1) safepoint statistics -XX:+PrintSafepointStatistics -XX:PrintSafepointStatisticsCount=1, (2) logging vm output -XX:+LogVMOutput, (3) -XX:+UnsyncloadClass). (4) -XX:GuaranteedSafepointInterval=N.
info.opt.eliminate.locks.enabled=-XX:+EliminateLocks is redundant (enabled by default) and can be removed. 
info.opt.experimental.vm.options.enabled=Experimental options are enabled with -XX:+UnlockExperimentalVMOptions. Experimental options are generally not recommended for production. Consider removing this option and any related experimental options unless there is a valid use case, and testing has shown it does not introduce any issues.
info.opt.g1.summarize.rset.stats.output=Summarized remembered set processing output is enabled (e.g. -XX:+G1SummarizeRSetStats -XX:G1SummarizeRSetStatsPeriod=1). This is verbose logging generally enabled for short periods of time to address specific tuning issues. If there is not a good use case for this output, do not enable it.
info.opt.heap.dump.on.oome.missing=Consider adding -XX:+HeapDumpOnOutOfMemoryError, a standard recommended option to generate a heap dump when the first thread throws OutOfMemoryError. It does not impact performance (until the heap is actually written out) and generally should always be used, as it provides critical information in case of a memory error.
info.opt.heap.dump.path.missing=Consider using -XX:HeapDumpPath to specify a directory where heap dumps are created (e.g. -XX:HeapDumpPath=/mypath/). If this option is not used, heap dumps will be created in the directory defined by the user.dir environment variable.
info.opt.heap.max.missing=The maximum heap size is not being set. 
info.opt.instrumentation=Instrumentation is being used:
info.opt.jdk11.print.gc.details.missing=Consider logging detailed gc information with -Xlog:gc* to output details needed for GC analysis (e.g. generation, metaspace, times data).
info.opt.jdk8.gc.log.file.rotation.disabled=GC log file rotation is disabled (-XX:-UseGCLogFileRotation). Consider enabling rotation to protect disk space.
info.opt.jdk8.gc.log.file.rotation.not.enabled=Consider enabling gc log file rotation with GC log file rotation (-XX:+UseGCLogFileRotation -XX:GCLogFileSize=N[K|M|G] -XX:NumberOfGCLogFiles=N) to protect disk space.
info.opt.jdk8.print.adaptive.resize.plcy.disabled=Adaptive Resize Policy output is disabled with -XX:-PrintAdaptiveSizePolicy. It is disabled by default, so this option is redundant. Verify the intent is not to enable it with XX:+PrintAdaptiveSizePolicy.
info.opt.jdk8.print.adaptive.resize.plcy.enabled=Adaptive Resize Policy output is enabled with -XX:+PrintAdaptiveSizePolicy. It is not a standard recommended GC logging option and is typically only enabled for special troubleshooting/analysis. If there is no reason to use it, remove it for less verbose logging.
info.opt.jdk8.print.fls.statistics=The -XX:PrintFLSStatistics option is being used. The additional data output with this option is not typically needed and adds significant logging overhead. If there is not a good use case for using this option, remove it.
info.opt.jdk8.print.gc.details.missing=Consider logging detailed gc information with -XX:+PrintGCDetails to output details needed for GC analysis (e.g. generation, metaspace, times data).
info.opt.jdk8.print.heap.at.gc=The -XX:+PrintHeapAtGC option is causing additional heap information to be output in the gc log. The additional data is not typically used for gc analysis. If there is not a good use case for enabling this option, remove it to reduce gc logging overhead.
info.opt.jdk8.print.promotion.failure=The -XX:+PrintPromotionFailure option is being used. The additional data output with this option is not generally needed. If there is not a good use case for using this option, consider removing it.
info.opt.jdk8.print.reference.gc.enabled=Consider removing -XX:+PrintReferenceGC. It is not a standard recommended GC logging option and is typically only enabled for special troubleshooting/analysis. If there is not a good use case for enabling this option, remove it to reduce gc logging overhead.
info.opt.jdk8.print.string.dedup.stats.enabled=Consider removing -XX:+PrintStringDeduplicationStatistics. It is not a standard recommended GC logging option and is typically only enabled for special troubleshooting/analysis. If there is no reason to use it, remove it for less verbose logging.
info.opt.jdk8.print.tenuring.distribution=The -XX:+PrintTenuringDistribution option is enabled. The additional data output with this option is not typically used for gc analysis. If there is not a good use case for enabling this option, remove it to reduce gc logging overhead.
info.opt.jfr=Java Flight Recorder (JFR) is being used.
info.opt.jmx.enabled=JMX is enabled with -Dcom.sun.management.jmxremote or -XX:+ManagementServer. This in and of itself does not add significant overhead; however, there is additional overhead when a tool (e.g. jconsole) polls for information. The impact on performance will depend on what is being polled and how often.
info.opt.large.page.size.in.bytes.linux=-XX:LargePageSizeInBytes has no meaning on Linux and can be removed. The page size is determined by the page size the kernel is set to support (Hugepagesize).
info.opt.large.page.size.in.bytes.windows=-XX:LargePageSizeInBytes has no meaning on Windows and can be removed. The page size is fixed at 2MB. 
info.opt.max.perm.size=There is an attempt to set the maximum permanent generation size with -XX:MaxPermSize. The permanent generation space was replaced by the metaspace in JDK8. The option is being ignored and should be removed.
info.opt.max.tenuring.override=The number of times an object is copied between survivor spaces is being set with -XX:MaxTenuringThreshold=N (0-15). 0 = disabled. 15 (default) = promote when the survivor space fills. Unless testing has shown this improves performance, consider removing this option to allow the default value to be applied.
info.opt.metaspace=Initial and/or max metaspace size is being set. This is generally not recommended. Reference: https://access.redhat.com/solutions/1489263.
info.opt.metaspace.class.metadata=Metaspace includes class metadata only (no compressed class space).
info.opt.missing=No JVM options.
info.opt.metaspace.class.metadata.and.comp.class.space=Metaspace includes class metadata plus compressed class space.
info.opt.new.ratio.inverted=The young generation is larger than the tenured generation. It's possible this is optimal for the application object lifetimes; however, the tenured generation is typically larger. Ensure that testing supports the larger young generation, as the young:tenured ratio has a major impact on generational collector performance.
info.opt.native=Native library is being used:
info.opt.perf.data.disabled=Consider replacing -XX:-UsePerfData with -XX:+PerfDisableSharedMem. This will disable the writing of performance data to disk (/tmp/hsperfdata*) but still make it available via JMX.
info.opt.perm.size=There is an attempt to set the initial permanent generation size with -XX:PermSize. The permanent generation space was replaced by the metaspace in JDK8. The option is being ignored and should be removed.
info.opt.print.gc.application.concurrent.time=Remove -XX:+PrintGCApplicationConcurrentTime. It is redundant, as the same information can be calculated from the GC logging timestamps and durations. It adds overhead with no analysis value.
info.opt.rmi.dgc.client.gcInterval.redundant=The sun.rmi.dgc.client.gcInterval option can be removed as it has no affect when explicit garbage collection is disabled (-XX:+DisableExplicitGC).
info.opt.rmi.dgc.server.gcInterval.redundant=The sun.rmi.dgc.server.gcInterval option can be removed as it has no affect when explicit garbage collection is disabled (-XX:+DisableExplicitGC).
info.opt.server.redundant=The -server flag no longer serves a purpose and can be remove, as only the server JIT compiler is included in 64-bit JDKs.
info.opt.survivor.ratio=Survivor ratio, the size of the eden space compared to ONE survivor space, is being set with -XX:SurvivorRatio=N (e.g. -XX:SurvivorRatio=6).
info.opt.survivor.ratio.target=Target survivor ratio, the percentage of the survivor space allowed to be occupied, is being set with -XX:TargetSurvivorRatio=N (e.g. -XX:TargetSurvivorRatio=90).
info.opt.tiered.compilation.enabled=-XX:+TieredCompilation is redundant and can be removed, as tiered compilation is enabled by default in JDK8+.
info.opt.trace.class.unloading=The -XX:+TraceClassUnloading option is enabled, causing class unloading information to be output to the gc log. This is typically only enabled for special troubleshooting/analysis. If there is no reason to use it, remove it for less verbose logging.
info.opt.undefined=Undefined JVM option(s):
info.opt.verbose.class=Class loading logging is enabled with -verbose:class. This is not a standard recommended logging option and is typically only enabled for special troubleshooting/analysis. If there is no reason to use it, remove it for less overhead.
info.rh.build.centos=Red Hat build of OpenJDK on CentOS.
info.rh.build.linux.zip=Red Hat build of OpenJDK Linux zip install.
info.rh.build.not=JDK does not appear to be a Red Hat build.
info.rh.build.possible=Red Hat build of OpenJDK possible, but not positively identified.
info.rh.build.rpm.based=Red Hat build of OpenJDK from rpm (e.g. jlink custom runtime, sym link to rpm install, rpm extract).
info.rh.build.rpm.install=Red Hat build of OpenJDK rpm install.
info.rh.build.windows.zip=Red Hat build of OpenJDK Windows zip install.
info.rh.opt.experimental.shenandoah=Shenandoah is not an experimental garbage collector in the Red Hat build of OpenJDK and does not require -XX:+UnlockExperimentalVMOptions.
info.sigcode.bus.adraln=Signal code BUS_ADRALN: The memory address that has an invalid address alignment for the CPU.
info.sigcode.bus.adrerr=Signal code BUS_ADRERR: The memory address does not exist.
info.sigcode.bus.adrerr.linux=Signal code BUS_ADRERR: The memory address does not exist. This can happen on Linux when an mmap'ed file is truncated (e.g. a threading issue where 2 threads access a file at the same time).
info.sigcode.bus.objerr=Signal code BUS_OBJERR: Hardware issue.
info.sigcode.ill.illopn=Signal code ILL_ILLOPN: Illegal operand.
info.sigcode.segv.accerr=Signal code SEGV_ACCERR: The access is not allowed. For example: (1) Attempting to write to read-only memory. (2) Attempting to write to protected (OS) memory. (3) Attempting to access an array at an index greater than the array size (out of bounds).
info.sigcode.segv.maperr=Signal code SEGV_MAPERR: The memory address is not mapped to an object.
info.sigcode.si.kernel=Signal code SI_KERNEL: Sent by the kernel.
info.sigcode.si.user=Signal code SI_USER: Sent by a process or thread in the current process calling kill.
info.signo.exception.access.violation=Signal code EXCEPTION_ACCESS_VIOLATION: Segmentation fault. Accessing valid memory in an invalid way.
info.signo.sigbus=Signal number SIGBUS: Invalid memory address.
info.signo.sigill=Signal number SIGILL: Illegal instruction at the processor.
info.signo.sigsegv=Signal number SIGSEGV: Segmentation fault. Accessing valid memory in an invalid way.
info.stack.no.vm.code=The stack trace does not contain VM code.
info.storage.aws=AWS block storage.
info.storage.nfs=NFS storage.
info.storage.unknown=Unknown storage.
info.swap.disabled=Swap has been disabled. This can be an indication the JVM is running in a container environment. Reference: https://access.redhat.com/solutions/3242331.
info.swapping=>5% swap space being used at the time of the crash. This is not necessarily bad. It is only a snapshot in time, and it doesn't necessarily mean the Java process is swapping. However, since swapping is very bad for Java performance, it should be verified that the Java process is indeed not swapping.
info.truncated=Truncated fatal error log.
warn.cms.incremental.mode=The CMS collector is being run in incremental mode. Concurrent phases are periodically stopped so application threads can run. This is useful on systems with 1-2 processors that cannot afford to dedicate cpu to the concurrent phases. Remove -XX:+CMSIncrementalMode unless testing has shown it improves performance.
warn.jdk.debug.symbols=Verify the JDK debug symbols are installed. Debug symbols can provide more detailed information in the fatal error log that is critical for analyzing issues in VM code. If they are not installed, reproduce the issue with the JDK debug symbols installed. Reference: https://access.redhat.com/solutions/5419761.
warn.jdk.not.latest=JDK is not the latest version. Latest version is 
warn.jdk.not.lts=JDK is not a Long Term Support (LTS) version.
warn.opt.adaptive.size.policy.disabled=Adaptive size policy is disabled (-XX:-UseAdaptiveSizePolicy), and minimum heap size (-Xms, -XX:InitialHeapSize) and maximum heap size (-Xmx, -XX:MaxHeapSize) are not equal. The JVM will not be able to increase the heap beyond the minimum heap size. Remove -XX:-UseAdaptiveSizePolicy. Reference: https://access.redhat.com/solutions/5565311.
warn.opt.biased.locking.disabled=Biased locking is disabled. Biased locking is a threading optimization that benefits objects that are only locked by a single thread. This is the typical use case, and it is enabled by default. Consider removing -XX:-UseBiasedLocking unless testing has shown that disabling biased locking improves performance.
warn.opt.bytecode.back.comp.disabled=Bytecode background compilation is disabled. Remove -Xbatch or -XX:-BackgroundCompilation to compile bytecode in the background so threads do not block waiting but instead run in interpreter mode until the compilation is complete.
warn.opt.bytecode.compile.disabled=Compilation to native code is disabled. Remove -Xint to allow the just in time (JIT) compiler to compile to native code for increased performance.
warn.opt.bytecode.compile.first.invocation=Methods being compiled on first invocation. Remove -Xcomp to enabled the JVM to efficiently decide when to compile methods into bytecode.
warn.opt.cgroup.memory.limit=Consider removing -XX:+UseCGroupMemoryLimitForHeap, an experimental option replaced by auto-detection of container limits in recent JDKs and removed altogether in JDK 11. See: https://bugs.openjdk.java.net/browse/JDK-8194086.
warn.opt.class.histogram=Class histogram output in gc logging due to one of the following options: -XX:+PrintClassHistogram, -XX:+PrintClassHistogramBeforeFullGC, -XX:+PrintClassHistogramAfterFullGC. These are heavyweight options that can output tens of thousands of logging lines and have limited use cases for troubleshooting memory leaks. Generally memory leaks are investigated by getting a heap dump. If there is not a good use case for this output, do not enable it.
warn.opt.class.unloading.disabled=Class unloading is disabled with -XX:-ClassUnloading. Remove to allow the default unloading unreachable classes to collect metaspace.
warn.opt.cms.class.unloading.disabled=CMS collection of metaspace is disabled with -XX:-CMSClassUnloadingEnabled. Remove to allow the default unloading unreachable classes to collect metaspace in the CMS concurrent cycle and avoid metaspace collections being done by a slow (single threaded) serial collector.
warn.opt.cms.inc.mode.with.init.occup.fract=When the CMS collector is run in incremental mode, the CMS initiating occupancy fraction is ignored. Remove one of the following options: (1) -XX:+CMSIncrementalMode, (2) -XX:CMSInitiatingOccupancyFraction=<n>.
warn.opt.cms.par.new.disabled=The PAR_NEW collector is disabled with -XX:-UseParNewGC, resulting in the SERIAL_NEW collector being used instead. Serial collectors are single-thread, which means they can take a long time to collect a large heap. For optimal performance on multi cpu/core systems, the PAR_NEW collector should be enabled with -XX:+UseParNewGC.
warn.opt.cms.parallel.initial.mark.disabled=Multi-threaded CMS initial mark is disabled with -XX:-CMSParallelInitialMarkEnabled. Remove -XX:-CMSParallelInitialMarkEnabled and let the JVM determine the setting based on resources.
warn.opt.cms.parallel.remark.disabled=Multi-threaded CMS remark is disabled with -XX:-CMSParallelRemarkEnabled. Remove -XX:-CMSParallelRemarkEnabled and let the JVM determine the setting based on resources.
warn.opt.comp.class.disabled.heap.lt.32g=Compressed class pointers are disabled with -XX:-UseCompressedClassPointers, and heap < 32G. One disadvantage of 64-bit is increased heap size due to increased pointer size. Compressed class pointers can be used on heaps < 32G to compress references to 32 bits, allowing class pointer and heap sizes on the order of 32-bit. Remove -XX:-UseCompressedClassPointers and let the JVM determine the setting based on resources.
warn.opt.comp.class.disabled.heap.unk=Compressed class pointers are disabled with -XX:-UseCompressedClassPointers. One disadvantage of 64-bit is increased heap size due to increased pointer size. Compressed class pointers can be used on heaps < 32G to compress references to 32 bits, allowing class pointer and heap sizes on the order of 32-bit. Remove -XX:-UseCompressedClassPointers and let the JVM determine the setting based on resources.
warn.opt.comp.class.enabled.heap.gt.32g=Compressed class pointers are enabled with -XX:+UseCompressedClassPointers, and heap >= 32G. Compressed object references cannot be used on heaps >= 32G. Remove -XX+-UseCompressedClassPointers and let the JVM determine the setting based on resources.
warn.opt.comp.class.size.heap.gt.32g=Compressed class pointers space size is set (-XX:CompressedClassSpaceSize), and heap >= 32G. Remove -XX:CompressedClassSpaceSize, as compressed object references should not be used on heaps >= 32G.
warn.opt.comp.oops.disabled.heap.lt.32g=Compressed object references are disabled with -XX:-UseCompressedOops, and heap < 32G. One disadvantage of 64-bit is increased heap size due to increased pointer size. Compressed class pointers can be used on heaps < 32G to compress references to 32 bits, allowing class pointer and heap sizes on the order of 32-bit. Remove -XX:-UseCompressedOops and let the JVM determine the setting based on resources.
warn.opt.comp.oops.disabled.heap.unk=Compressed object references are disabled with -XX:-UseCompressedOops. One disadvantage of 64-bit is increased heap size due to increased pointer size. Compressed class pointers can be used on heaps < 32G to compress references to 32 bits, allowing class pointer and heap sizes on the order of 32-bit. Remove -XX:-UseCompressedOops and let the JVM determine the setting based on resources.
warn.opt.comp.oops.enabled.heap.gt.32g=Compressed object references are enabled with -XX:+UseCompressedOops, and heap >= 32G. Compressed object references should not be used on heaps >= 32G. Remove -XX:+UseCompressedOops and let the JVM determine the setting based on resources.
warn.opt.container.perf.data.disk=If this is a container environment, it is recommended to disable the writing of performance data to disk (/tmp/hsperfdata*) with -XX:+PerfDisableSharedMem. Disk IOPS (Input/output Operations Per Second) is shared among containers. Eliminating disk access will prevent one workload monopolizing disk from impacting all containers.
warn.opt.explicit.gc.disabled=Explicit garbage collection has been disabled with -XX:+DisableExplicitGC. The JVM uses explicit garbage collection to manage direct memory (to free space when MaxDirectMemorySize is reached) and the Remote Method Invocation (RMI) system (to clean up unreachable remote objects). Disabling it for those use cases can cause a memory leak. Verify the application does not use direct memory (e.g. java.nio.DirectByteBuffer), does not make remote method calls or export remote objects like EJBs (everything runs in the same JVM), and does not depend on explicit garbage collection in some other way. Known applications that use direct memory: JBoss EAP7 (IO subsystem). If explicit garbage collection is required, remove -XX:+DisableExplicitGC, and if using the CMS or G1 collector, add -XX:+ExplicitGCInvokesConcurrent so explicit garbage collection is handled concurrently.
warn.opt.explicit.gc.disabled.concurrent=Remove -XX:+ExplicitGCInvokesConcurrent since explicit garbage collection has been disabled with -XX:+DisableExplicitGC.
warn.opt.explicit.gc.not.concurrent=Consider adding -XX:+ExplicitGCInvokesConcurrent so explicit garbage collection is handled concurrently by the CMS and G1 collectors. Or if not making remote method calls and not exporting remote objects like EJBs (everything runs in the same JVM), disable explicit garbage collection altogether with -XX:+DisableExplicitGC. Reference: https://access.redhat.com/solutions/21994.
warn.opt.fast.unordered.timestamps=Fast unordered timestamps are enabled with -XX:+UseFastUnorderedTimeStamps. Consider removing this option, as it is an experimental option known to cause logging issues.
warn.opt.g1.mixed.gc.live.thrshld.prcnt=The occupancy threshold for a region to be considered as a candidate region for a G1_CLEANUP collection is being specified with the -XX:G1MixedGCLiveThresholdPercent=N (default 65% JDK7/JDK8 < u40, 85% JDK8u40+). Consider removing this experimental option unless there is a valid use case (e.g. JDK8 <  u40: https://bugs.openjdk.java.net/browse/JDK-8059452) and testing has shown it does not introduce any issues.
warn.opt.heap.dump.on.oome.disabled=Remove -XX:-HeapDumpOnOutOfMemoryError and add -XX:+HeapDumpOnOutOfMemoryError instead (notice "+" vs. "-") for a heap dump to be generated when the first thread throws OutOfMemoryError. Generally this JVM argument should always be used, as it provides critical information in case of a memory error.
warn.opt.heap.dump.path.filename=A heap dump file name has been specified with the -XX:HeapDumpPath (e.g. -XX:HeapDumpPath=/mydir/heapdump.hprof). Generally you only want to specify a directory (e.g. -XX:HeapDumpPath=/mydir/) and let the JVM use the default file name, which includes the process id. If you specify a file name, heap dumps will not overwrite each other. Only the initial file will be written. Subsequent heap dumps will fail due to the existing file. Unless disk space is a concern, you typically do not want to lose data. Reference: https://access.redhat.com/solutions/21109
warn.opt.jdk11.gc.log.file.rotation.disabled=GC log file rotation is disabled with filecount=0. Set filecount to a non-zero value or remove it (default 5) to enable GC log file rotation.
warn.opt.jdk11.gc.log.file.size.0=Automatic GC log file rotation is disabled with filesize=0. Set filesize to a non-zero value or remove it (default 20M) to allow automatic log rotation.
warn.opt.jdk11.gc.log.file.size.small=GC log file size (filesize=N[K|M|G]) is small (< 5M). Data needed for troubleshooting could be lost due to excessive log rotation. Consider increasing the size.
warn.opt.jdk8.gc.log.file.num.rotation.disabled=Number of GC log files is defined (-XX:NumberOfGCLogFiles), yet GC log file rotation is disabled. Either remove -XX:NumberOfGCLogFiles or enable GC log file rotation with -XX:+UseGCLogFileRotation.
warn.opt.jdk8.gc.log.file.size.small=GC log file size (-XX:GCLogFileSize=N[K|M|G]) is small (< 5M). Data needed for troubleshooting could be lost due to excessive log rotation. Consider increasing the size.
warn.opt.jdk8.print.gc.details.disabled=PrintGCDetails is disabled. This is a standard recommended logging option that outputs details needed for GC analysis (e.g. generation, Metaspace, and Times data). Replace -XX:-PrintGCDetails with -XX:+PrintGCDetails. Or, if both -XX:-PrintGCDetails and -XX:+PrintGCDetails are specified, remove -XX:-PrintGCDetails.
warn.opt.jdk8.use.vm.interruptible.io=-XX:-UseVMInterruptibleIO is obsolete and should be removed. It is deprecated in JDK8 and removed in JDK11. 
warn.opt.metaspace.lt.comp.class=MaxMetaspaceSize is less than CompressedClassSpaceSize. MaxMetaspaceSize includes CompressedClassSpaceSize, so MaxMetaspaceSize should be larger than CompressedClassSpaceSize. If MaxMetaspaceSize is set smaller than CompressedClassSpaceSize, the JVM auto adjusts CompressedClassSpaceSize as follows: CompressedClassSpaceSize = MaxMetaspaceSize - (2 * InitialBootClassLoaderMetaspaceSize).
warn.opt.print.class.histogram=The -XX:+PrintClassHistogram option will cause a class histogram to be output in the gc logging when a thread dump is taken. It is a heavyweight option that forces a full collection and can output tens of thousands of logging lines. It has limited use cases for troubleshooting memory leaks. Generally memory leaks are investigated by getting a heap dump. If there is not a good use case for enabling this option, remove it to reduce gc logging overhead.
warn.opt.print.class.histogram.after.full.gc=The -XX:+PrintClassHistogramAfterFullGC option will cause a class histogram to be output after every full collection. It is a heavyweight option that can output tens of thousands of logging lines. It has limited use cases for troubleshooting memory leaks. Generally memory leaks are investigated by getting a heap dump. If there is not a good use case for enabling this option, remove it to reduce gc logging overhead.
warn.opt.print.class.histogram.before.full.gc=The -XX:+PrintClassHistogramBeforeFullGC option will cause a class histogram to be output before every full collection. It is a heavyweight option that can output tens of thousands of logging lines. It has limited use cases for troubleshooting memory leaks. Generally memory leaks are investigated by getting a heap dump. If there is not a good use case for enabling this option, remove it to reduce gc logging overhead.
warn.opt.rmi.dgc.client.gcInterval.small=The sun.rmi.dgc.client.gcInterval value is small. A typical value is at least one hour (e.g. -Dsun.rmi.dgc.client.gcInterval=3600000).
warn.opt.rmi.dgc.server.gcInterval.small=The sun.rmi.dgc.server.gcInterval value is small. A typical value is at least one hour (e.g. -Dsun.rmi.dgc.server.gcInterval=3600000).
warn.opt.rs=-Xrs prevents the JVM from handling signals. Issuing kill -3 or CTRL+Break will not work and will cause the Java processes to be terminated.
warn.opt.tenuring.disabled=Tenuring has been disabled with -XX:MaxTenuringThreshold=0 or by setting it to a value greater than 15 (e.g. -XX:MaxTenuringThreshold=32), resulting in objects surviving a young collection not being copied to a survivor space but being immediately promoted to the old generation. Unless testing has shown this makes sense for your application (e.g. mainly long live objects), consider removing this option to allow the default value to be applied.
warn.opt.use.membar=The -XX:+UseMembar option is being used. This was a workaround for a bug in old versions of JDK 1.6 (see http://bugs.java.com/view_bug.do?bug_id=6822370) and is not necessary with modern JVMs. If there is not a good use case for using this option, remove it, as it causes the JVM to use a memory barrier that slows down the JVM. 
warn.opt.verify.none=Class verification during loading has been disabled with -Xverify:none. This is unsupported and can result in corrupt or invalid classes being loaded, causing undetermined JVM behavior and crashes.
warn.rhel6=RHEL6 reached reached end of Maintenance Support II in November 2020. There will be no more RH builds of OpenJDK for RHEL6.	
warn.swapping=Swap usage >= 20%. Memory usage should be monitored to determine if physical memory should be increased and/or memory demands decreased.
warn.thread.stack.size.small=Thread stack size is less than 128K.
warn.thread.stack.size.tiny=Thread stack size is less than 1K. Were units (e.g. 'K') left off by mistake?
warn.unidentified.log.line.report=Unidentified log line(s). Please submit an issue so we can investigate: https://github.com/mgm3746/krashpad/issues. If attaching a fatal error log, be sure to review it and remove any sensitive information.